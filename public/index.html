<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bybit Signal Detector - Messages</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }





        .messages-container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            padding: 20px;
            max-height: 70vh;
            overflow-y: auto;
        }

        .message {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
            border-left: 4px solid #4CAF50;
            transition: all 0.3s ease;
            cursor: pointer;
            text-decoration: none;
            color: inherit;
            display: block;
            text-align: center;
        }

        .message:hover {
            transform: translateX(5px) scale(1.02);
            background: rgba(255, 255, 255, 0.25);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        .message-image {
            width: 100%;
            max-width: 400px;
            height: auto;
            border-radius: 8px;
            margin: 15px auto;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            display: block;
        }

        .message-header {
            display: flex;
            justify-content: center;
            margin-bottom: 10px;
        }

        .timestamp {
            font-size: 1.6em; /* Increased by 1 more size */
            color: rgba(255, 255, 255, 0.6);
            text-align: center;
        }

        .message-content {
            line-height: 1.8;
            text-align: center;
            font-size: 1.6em; /* Increased by 1 more size */
        }

        .message-line {
            margin: 8px 0;
        }

        .scan-finished-time {
            margin-top: 10px;
            font-size: 1.6em; /* Increased by 1 more size */
            color: rgba(255, 255, 255, 0.6);
            text-align: center;
        }

        .loading {
            text-align: center;
            padding: 40px;
            font-size: 1.2em;
        }

        .error {
            text-align: center;
            padding: 40px;
            color: #ff6b6b;
            font-size: 1.2em;
        }



        .scan-finished {
            border-left-color: #2196F3;
            background: rgba(33, 150, 243, 0.1);
        }

        .reload-button {
            width: 110%; /* 10% wider */
            max-width: 660px; /* 10% wider max-width */
            margin: 20px auto;
            padding: 16.5px 22px; /* 10% more padding (height) */
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            display: block;
        }

        .reload-button:hover {
            background: linear-gradient(135deg, #45a049, #4CAF50);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        }

        .reload-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .no-messages {
            text-align: center;
            padding: 40px;
            color: rgba(255, 255, 255, 0.7);
            font-style: italic;
        }

        /* Scrollbar styling */
        .messages-container::-webkit-scrollbar {
            width: 8px;
        }

        .messages-container::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        .messages-container::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
        }

        .messages-container::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        @media (max-width: 768px) {
            .message {
                padding: 15px;
            }

            .message-image {
                max-width: 100%;
            }

            .timestamp {
                font-size: 0.8em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="messages-container" id="messagesContainer">
            <div class="loading">üîÑ Loading messages...</div>
        </div>

        <button class="reload-button" onclick="window.location.reload()">
            üîÑ Reload Page
        </button>
    </div>

    <script>
        let messages = [];
        let socket = null;

        // WebSocket connection
        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}`;

            socket = new WebSocket(wsUrl);

            socket.onopen = function() {
                console.log('WebSocket connected');
            };

            socket.onmessage = function(event) {
                const data = JSON.parse(event.data);
                if (data.type === 'new_message') {
                    // Add new message to the beginning of the array
                    messages.unshift(data.message);
                    // Keep only last 100 messages
                    if (messages.length > 100) {
                        messages.splice(100);
                    }
                    renderMessages();
                }
            };

            socket.onclose = function() {
                console.log('WebSocket disconnected');
                // Reconnect after 3 seconds
                setTimeout(connectWebSocket, 3000);
            };

            socket.onerror = function(error) {
                console.error('WebSocket error:', error);
            };
        }



        async function loadMessages() {
            try {
                const response = await fetch('/api/messages');
                const data = await response.json();
                messages = data.messages || [];
                renderMessages();
            } catch (error) {
                console.error('Error loading messages:', error);
                document.getElementById('messagesContainer').innerHTML =
                    '<div class="error">‚ùå Error loading messages. Please try again.</div>';
            }
        }

        function renderMessages() {
            const container = document.getElementById('messagesContainer');

            if (messages.length === 0) {
                container.innerHTML = '<div class="no-messages">üì≠ No messages yet</div>';
                return;
            }

            const messagesHtml = messages.map(msg => {
                const isScanFinished = msg.text.includes('üîç Scan finished');
                const messageClass = isScanFinished ? 'message scan-finished' : 'message';
                const symbolInfo = getSymbolInfo(msg.text);

                // For scan finished messages, show timestamp above the message content
                if (isScanFinished) {
                    return `
                        <a href="${symbolInfo.url}" target="_blank" class="${messageClass}">
                            ${msg.image ? `<img src="${msg.image}" alt="Chart" class="message-image">` : ''}
                            <div class="message-content">
                                ${formatMessageContent(msg.text)}
                                <div class="scan-finished-time">${formatTimestamp(msg.timestamp)}</div>
                            </div>
                        </a>
                    `;
                } else {
                    return `
                        <a href="${symbolInfo.url}" target="_blank" class="${messageClass}">
                            <div class="message-header">
                                <div class="timestamp">${formatTimestamp(msg.timestamp)}</div>
                            </div>
                            ${msg.image ? `<img src="${msg.image}" alt="Chart" class="message-image">` : ''}
                            <div class="message-content">
                                ${formatMessageContent(msg.text)}
                            </div>
                        </a>
                    `;
                }
            }).join('');

            container.innerHTML = messagesHtml;
        }

        function getSymbolInfo(text) {
            const lines = text.split('\n');
            const firstLine = lines[0].trim();

            // Check if it's a scan finished message
            if (firstLine.includes('üîç Scan finished')) {
                return {
                    symbol: 'üîç Scan Finished',
                    url: '#'
                };
            }

            // Check if first line looks like a symbol (ends with USDT)
            if (firstLine.endsWith('USDT') && firstLine.length > 4) {
                const symbol = firstLine;
                const url = `https://www.bybit.com/trade/usdt/${symbol}`;
                return { symbol, url };
            }

            return {
                symbol: firstLine,
                url: '#'
            };
        }

        function formatMessageContent(text) {
            const lines = text.split('\n');

            // Handle scan finished messages specially
            if (text.includes('üîç Scan finished')) {
                return lines.map((line, index) => {
                    // Skip empty lines before scan finished
                    if (line.trim() === '' && lines[index + 1] && lines[index + 1].includes('üîç Scan finished')) {
                        return '';
                    }
                    return line ? `<div class="message-line">${line}</div>` : '';
                }).filter(line => line !== '').join('');
            }

            return lines.map(line =>
                `<div class="message-line">${line || '&nbsp;'}</div>`
            ).join('');
        }

        function formatTimestamp(timestamp) {
            const date = new Date(timestamp);
            // Convert to UTC+2
            const utcPlus2 = new Date(date.getTime() + (2 * 60 * 60 * 1000));

            // Format as DD/MM/YYYY HH:MM
            const day = utcPlus2.getUTCDate().toString().padStart(2, '0');
            const month = (utcPlus2.getUTCMonth() + 1).toString().padStart(2, '0');
            const year = utcPlus2.getUTCFullYear();
            const hours = utcPlus2.getUTCHours().toString().padStart(2, '0');
            const minutes = utcPlus2.getUTCMinutes().toString().padStart(2, '0');

            return `${day}/${month}/${year} ${hours}:${minutes}`;
        }

        // Mouse drag-to-scroll functionality (for RDP)
        let isScrollMode = false;
        let startY = 0;
        let lastScrollTime = 0;
        let scrollTimeout = null;
        let isDragging = false;

        document.addEventListener('mousedown', (e) => {
            const messageCard = e.target.closest('.message');
            if (messageCard && e.button === 0) { // Left mouse button only
                isScrollMode = true;
                isDragging = false;
                startY = e.clientY;

                // Set a timeout to distinguish between click and drag
                scrollTimeout = setTimeout(() => {
                    // If we're still holding after 200ms, prepare for scroll mode
                    if (isScrollMode) {
                        isDragging = true;
                        messageCard.style.pointerEvents = 'none';
                        document.body.style.userSelect = 'none'; // Prevent text selection
                        document.body.style.cursor = 'grabbing';
                    }
                }, 200);

                e.preventDefault();
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (isScrollMode) {
                const currentY = e.clientY;
                const deltaY = startY - currentY;

                // If we've moved more than 10px, we're dragging not clicking
                if (Math.abs(deltaY) > 10) {
                    clearTimeout(scrollTimeout);
                    isDragging = true;

                    // Disable link navigation and show drag cursor
                    const messageCard = e.target.closest('.message');
                    if (messageCard) {
                        messageCard.style.pointerEvents = 'none';
                    }
                    document.body.style.userSelect = 'none';
                    document.body.style.cursor = 'grabbing';
                }

                // Only scroll if we're in drag mode
                if (isDragging) {
                    // Throttle scroll events for smooth performance
                    const now = Date.now();
                    if (now - lastScrollTime > 16) { // ~60fps
                        const container = document.getElementById('messagesContainer');
                        const scrollAmount = deltaY * 1.5; // Normal scroll sensitivity

                        // Apply scroll with boundaries
                        const newScrollTop = container.scrollTop + scrollAmount;
                        const maxScroll = container.scrollHeight - container.clientHeight;

                        // Stop at top/bottom boundaries
                        container.scrollTop = Math.max(0, Math.min(newScrollTop, maxScroll));

                        startY = currentY;
                        lastScrollTime = now;
                    }
                }

                if (isDragging) {
                    e.preventDefault();
                }
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (isScrollMode) {
                clearTimeout(scrollTimeout);

                // If we were dragging, prevent the click event
                if (isDragging) {
                    e.preventDefault();
                    e.stopPropagation();
                }

                // Re-enable link navigation and restore cursor
                setTimeout(() => {
                    const messageCards = document.querySelectorAll('.message');
                    messageCards.forEach(card => {
                        card.style.pointerEvents = 'auto';
                    });
                    document.body.style.userSelect = 'auto';
                    document.body.style.cursor = 'default';
                }, isDragging ? 100 : 0);

                isScrollMode = false;
                isDragging = false;
            }
        });

        // Handle mouse leave (when mouse leaves the window)
        document.addEventListener('mouseleave', (e) => {
            if (isScrollMode) {
                clearTimeout(scrollTimeout);

                // Re-enable link navigation and restore cursor
                const messageCards = document.querySelectorAll('.message');
                messageCards.forEach(card => {
                    card.style.pointerEvents = 'auto';
                });
                document.body.style.userSelect = 'auto';
                document.body.style.cursor = 'default';

                isScrollMode = false;
                isDragging = false;
            }
        });

        // Load initial messages and connect WebSocket
        loadMessages();
        connectWebSocket();
    </script>
</body>
</html>
